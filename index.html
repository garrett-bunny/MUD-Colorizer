<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- If you're reading this, you might like this tool, but it would be NICE if you could credit me somehow.
         Demon, Despair, Asmodeus, or Jeff. https://www.github.com/coffee-nerd/
         Please leave this line in the code. Preferably we can collaborate and you can just make a pull request. -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MUD Colorizer</title>
    <style>
      body {
        background-color: black;
        color: white;
        /* Default to Fira Code */
        font-family: "Fira Code", monospace;
        padding: 20px;
      }
      #output {
        white-space: pre-wrap;
        margin-top: 20px;
        border: 1px solid #444;
        padding: 10px;
        background-color: #111;
      }
      #controls {
        margin-bottom: 20px;
      }
      label {
        color: white;
        font-size: 1rem;
        margin-right: 10px;
      }
      textarea {
        width: 100%;
        height: 150px;
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 10px;
        font-family: inherit;
        resize: vertical;
      }
      select {
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 5px;
        font-family: inherit;
        margin-right: 10px;
      }
      .preview-box {
        display: inline-block;
        vertical-align: middle;
        width: 100px;
        height: 20px;
        margin-left: 10px;
        border: 1px solid #444;
        background: black;
      }
      .mode-selector {
        margin-bottom: 20px;
      }
      .mode-selector input {
        margin-right: 5px;
      }
      .disabled {
        opacity: 0.5;
        pointer-events: none;
      }
      /* Custom Gradient Inputs */
      .custom-gradient-input {
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 5px;
        font-family: inherit;
      }
      /* Toggle buttons styling */
      #toggleCustomGradientButton,
      #toggleManageCustomGradients {
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 5px 10px;
        font-family: inherit;
        cursor: pointer;
        margin-bottom: 10px;
      }
      /* Shake animation */
      @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        50% { transform: translateX(5px); }
        75% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
      }
      .shake {
        animation: shake 0.3s;
      }
      .invalid {
        border: 2px solid red !important;
      }
      /* Manage Custom Gradients section */
      #manageCustomGradients {
        display: none;
        border: 1px solid #444;
        padding: 10px;
        margin-top: 10px;
      }
      #manageCustomGradients h3 {
        margin-top: 0;
      }
      /* Inline help text */
      .help-text {
        font-size: 0.8rem;
        color: #888;
      }
      /* Styling for each editable custom gradient item */
      .custom-gradient-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        border-bottom: 1px solid #444;
        padding-bottom: 5px;
      }
      .custom-gradient-item input[type="text"] {
        margin-right: 10px;
      }
      .custom-gradient-preview {
        width: 80px;
        height: 20px;
        border: 1px solid #444;
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <h1 style="color: white">MUD Colorizer</h1>
    <div id="controls">
      <!-- Mode Selection -->
      <div class="mode-selector">
        <label>Select Mode:</label>
        <input type="radio" id="editMode" name="mode" value="edit" checked />
        <label for="editMode">Edit Mode</label>
        <input
          type="radio"
          id="viewMode"
          name="mode"
          value="view"
          style="margin-left: 20px"
        />
        <label for="viewMode">Viewer Mode</label>
      </div>

      <!-- Font Selection -->
      <div>
        <label for="fontSelector">Select Font:</label>
        <select id="fontSelector">
          <option value="'Fira Code', monospace" selected>Fira Code</option>
          <option value="'Courier New', monospace">Courier New</option>
          <option value="'Hack', monospace">Hack</option>
          <option value="'JetBrains Mono', monospace">JetBrains Mono</option>
          <option value="'Roboto Mono', monospace">Roboto Mono</option>
          <option value="'Source Code Pro', monospace">Source Code Pro</option>
          <option value="'Ubuntu Mono', monospace">Ubuntu Mono</option>
          <option value="'Monaco', monospace">Monaco</option>
          <option value="'Consolas', monospace">Consolas</option>
          <option value="'Anonymous Pro', monospace">Anonymous Pro</option>
        </select>
      </div>
      <br />

      <!-- Code Format Selection -->
      <div>
        <label for="formatSelector">Color Codes:</label>
        <select id="formatSelector">
          <option value="@x">Xterm: @xNNN</option>
          <option value="{x">Xterm: {xNNN</option>
          <option value="$x">Xterm: $xNNN</option>
          <option value="@[F">Xterm F-colors: @[FNNN]</option>
          <option value="^[F">Xterm F-colors: ^[FNNN]</option>
          <option value="\t">Xterm Builder F-colors: \t[FNNN]</option>
          <option value="&amp;">Xterm: &amp;NNN</option>
          <option value="SuS">Sundering Shadows NNN</option>
        </select>
      </div>
      <br />

      <!-- Text Input -->
      <label for="textInput">Paste Your Text:</label><br />
      <textarea id="textInput" placeholder="Paste your text here..."></textarea>
      <br /><br />

      <!-- Gradient Selection -->
      <div id="gradientControls">
        <div>
          <label for="gradientSelect">Select Gradient:</label>
          <select id="gradientSelect"></select>
          <span class="preview-box" id="gradientPreview"></span>
          &nbsp;&nbsp;
          <input type="checkbox" id="invertGradient" />
          <label for="invertGradient">Invert</label>
        </div>
        <br />

        <!-- Toggle button for Custom Gradient -->
        <div>
          <input type="button" id="toggleCustomGradientButton" value="Create custom gradient" />
        </div>
        <br />

        <!-- Add New Gradients (hidden by default) -->
        <div id="addGradient" style="display: none;">
          <div>
            <label>Add New Gradient:</label>
            <label for="newGradientName">Name</label>
            <input
              type="text"
              id="newGradientName"
              placeholder="My Gradient"
              required
              pattern="^[\w\s]+$"
              title="Enter a name (letters, numbers, and spaces only)"
              class="custom-gradient-input"
            />
            <small class="help-text">Allowed: letters, numbers, spaces</small>
            &nbsp;|&nbsp;
            <label for="newGradientCodes">Color Codes</label>
            <input
              type="text"
              id="newGradientCodes"
              placeholder="120 16 220 161"
              required
              pattern="^(?:[0-9]{1,3}(?:\s+[0-9]{1,3})*)$"
              title="Enter space-separated numbers between 0 and 255"
              class="custom-gradient-input"
            />
            <small class="help-text">E.g.: 54 55 56 57</small>
            <span class="preview-box" id="customGradientPreview"></span>
            <input type="button" id="newGradientProcess" value="Add" />
          </div>
        </div>
        <br />

        <!-- Toggle button for managing custom gradients -->
        <div>
          <input type="button" id="toggleManageCustomGradients" value="Manage custom gradients" />
        </div>
        <br />

        <!-- Manage Custom Gradients Section -->
        <div id="manageCustomGradients">
          <h3>Custom Gradients</h3>
          <div id="customGradientsList"></div>
        </div>
        <br />

        <!-- Pattern Selection -->
        <div>
          <label for="patternSelect">Pattern:</label>
          <select id="patternSelect">
            <option value="original">Original</option>
            <option value="distributed">Distributed</option>
            <option value="symmetrical">Symmetrical</option>
          </select>
        </div>
      </div>
    </div>

    <div id="output"></div>

    <script type='text/javascript'>
      // Standard 16 color mapping
      const standardColorMap = {
        k: "#000000", // Black
        K: "#555555", // Bright Black (Gray)
        r: "#800000", // Dark Red
        R: "#ff0000", // Bright Red
        g: "#008000", // Dark Green
        G: "#00ff00", // Bright Green
        y: "#808000", // Dark Yellow
        Y: "#ffff00", // Bright Yellow
        b: "#000080", // Dark Blue
        B: "#0000ff", // Bright Blue
        m: "#800080", // Dark Magenta
        M: "#ff00ff", // Bright Magenta
        c: "#008080", // Dark Cyan
        C: "#00ffff", // Bright Cyan
        w: "#c0c0c0", // Dark White (Silver)
        W: "#ffffff", // Bright White
        D: "#333333", // Blackish
      };

      // Map standard color letters to an xterm index
      const standardColorToIndex = {
        k: 0,
        K: 8,
        r: 1,
        R: 9,
        g: 2,
        G: 10,
        y: 3,
        Y: 11,
        b: 4,
        B: 12,
        m: 5,
        M: 13,
        c: 6,
        C: 14,
        w: 7,
        W: 15,
        D: 8,
      };

      // Convert an Xterm color index (0-255) into an RGB hex color
      function xtermToRgbHex(colorIndex) {
        if (colorIndex < 16) {
          const standardColors = [
            "#000000",
            "#800000",
            "#008000",
            "#808000",
            "#000080",
            "#800080",
            "#008080",
            "#c0c0c0",
            "#808080",
            "#ff0000",
            "#00ff00",
            "#ffff00",
            "#0000ff",
            "#ff00ff",
            "#00ffff",
            "#ffffff",
          ];
          return standardColors[colorIndex];
        } else if (colorIndex >= 16 && colorIndex <= 231) {
          const base = colorIndex - 16;
          const r = (Math.floor(base / 36) % 6) * 51;
          const g = (Math.floor(base / 6) % 6) * 51;
          const b = (base % 6) * 51;
          return `rgb(${r},${g},${b})`;
        } else if (colorIndex >= 232 && colorIndex <= 255) {
          const gray = Math.round((colorIndex - 232) * 10 + 8);
          return `rgb(${gray},${gray},${gray})`;
        } else {
          return "#ffffff";
        }
      }
     // So what the hell even are these F colors? (Heh)
     // "F-colors" are essentially a shorthand notation for specifying colors in the 6×6×6 color cube used by xterm's 256-color palette. 
     //  Instead of using a direct numeric index (like @x123), an F-color (e.g. @[F123] or ^[F123]) breaks the color into three digits—
     //  each representing a value (0–5) for red, green, and blue respectively. The conversion function then maps these digits into the 
     //  appropriate xterm color index (from 16 to 231).
     //  In short, while they ultimately refer to colors in the xterm palette, the notation is different. They may appear to differ because:
     //  Xterm codes typically use a numeric index or direct hex representation.
     //  F-colors encode the red, green, and blue components as three digits, which are then converted into the xterm index.
     //  This extra layer of abstraction can make them seem different even though they're designed to represent the same range of colors.
      function fToRgbHex(fCode) {
        // fCode example: "F012" => r=0, g=1, b=2
        const codeStr = fCode.slice(1);
        const r = parseInt(codeStr.charAt(0), 10);
        const g = parseInt(codeStr.charAt(1), 10);
        const b = parseInt(codeStr.charAt(2), 10);
        const colorIndex = 16 + 36 * r + 6 * g + b;
        return xtermToRgbHex(colorIndex);
      }

      // This regex will match any valid color code token in group1,
      // and if not a valid token, it will match any single character (including $, @, {, &)
      // in group2.
      const regex = /(\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rRgGyYbBmMcCwWdD](?:\d{3})?|@[rRgGyYbBmMcCwWdD](?:\d{3})?|\&[rRgGyYbBmMcCwWdD](?:\d{3})?|\{[rRgGyYbBmMcCwWdD](?:\d{3})?|\{\d{3}|\&\d{3})|([\s\S])/g;

      function renderXterm(text) {
        let output = "";
        let currentColor = "#ffffff";

        text.replace(regex, (match, colorCode, textContent) => {
          if (colorCode) {
            if (
              (colorCode.startsWith("$x") ||
                colorCode.startsWith("@x") ||
                colorCode.startsWith("{x")) &&
              colorCode.length === 5
            ) {
              const idx = parseInt(colorCode.slice(2), 10);
              currentColor = xtermToRgbHex(idx);
            } else if (colorCode.startsWith("@[") && colorCode.endsWith("]")) {
              const inside = colorCode.slice(2, -1);
              currentColor = fToRgbHex(inside);
            } else if (colorCode.startsWith("^[") && colorCode.endsWith("]")) {
              const inside = colorCode.slice(2, -1);
              currentColor = fToRgbHex(inside);
            } else if (
              colorCode.startsWith("\\t[") &&
              colorCode.endsWith("]")
            ) {
              const inside = colorCode.slice(3, -1);
              currentColor = fToRgbHex(inside);
            } else if (colorCode.startsWith("&")) {
              const m = colorCode.match(/^&([rRgGyYbBmMcCwWdD])(\d{3})?$/);
              if (m) {
                if (m[2]) {
                  const idx = parseInt(m[2], 10);
                  currentColor = xtermToRgbHex(idx);
                } else {
                  const c = m[1];
                  currentColor = standardColorMap[c] || "#ffffff";
                }
              } else if (/^&\d{3}$/.test(colorCode)) {
                const idx = parseInt(colorCode.slice(1), 10);
                currentColor = xtermToRgbHex(idx);
              }
            } else if (colorCode.startsWith("{")) {
              if (colorCode.startsWith("{x") && colorCode.length === 5) {
                const idx = parseInt(colorCode.slice(2), 10);
                currentColor = xtermToRgbHex(idx);
              } else {
                const m = colorCode.match(/^\{([rRgGyYbBmMcCwWdD])(\d{3})?$/);
                if (m) {
                  if (m[2]) {
                    const idx = parseInt(m[2], 10);
                    currentColor = xtermToRgbHex(idx);
                  } else {
                    const c = m[1];
                    currentColor = standardColorMap[c] || "#ffffff";
                  }
                } else if (/^\{\d{3}$/.test(colorCode)) {
                  const idx = parseInt(colorCode.slice(1), 10);
                  currentColor = xtermToRgbHex(idx);
                }
              }
            } else if (colorCode === "@n") {
              currentColor = "#ffffff";
            } else if (colorCode.match(/^\$[rRgGyYbBmMcCwWdD](?:\d{3})?$/)) {
              const c = colorCode.charAt(1);
              currentColor = standardColorMap[c] || "#ffffff";
            } else if (colorCode.match(/^@[rRgGyYbBmMcCwWdD](?:\d{3})?$/)) {
              const c = colorCode.charAt(1);
              currentColor = standardColorMap[c] || "#ffffff";
            }
          } else if (textContent) {
            if (/\s/.test(textContent)) {
              output += escapeHtml(textContent);
            } else {
              output += `<span style="color: ${currentColor}">${escapeHtml(textContent)}</span>`;
            }
          }
        });
        return output;
      }

      function escapeHtml(text) {
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#039;",
        };
        return text.replace(/[&<>"']/g, function (m) {
          return map[m];
        });
      }

      function wrapColorCode(colorIndex) {
        const format = document.getElementById("formatSelector").value;
        if (format === "@x") {
          return `@x${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "{x") {
          return `{x${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "$x") {
          return `$x${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "&") {
          return `&${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "@[F") {
          let fCode = "F000";
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          } else {
            const clamped = Math.min(Math.max(colorIndex, 16), 231);
            const base = clamped - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          }
          return `@[${fCode}]`;
        } else if (format === "^[F") {
          let fCode = "F000";
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
        } else if (format === "SuS") {
          let fCode = format+"FFF"+format;
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = format+`${r}${g}${b}`+format;
          } else {
            const clamped = Math.min(Math.max(colorIndex, 16), 231);
            const base = clamped - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = format+`${r}${g}${b}`+format;
          }
          return `^[${fCode}]`;
        } else if (format === "\\t") {
          let fCode = "F000";
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          } else {
            const clamped = Math.min(Math.max(colorIndex, 16), 231);
            const base = clamped - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          }
          return `\\t[${fCode}]`;
        }
        return `@x${String(colorIndex).padStart(3, "0")}`;
      }

      function convertColorCodesToFormat(text, newFormat) {
        let converted = "";
        text.replace(regex, (match, colorCode, textContent) => {
          if (colorCode) {
            let colorIndex = null;
            if (
              (colorCode.startsWith("$x") ||
                colorCode.startsWith("@x") ||
                colorCode.startsWith("{x")) &&
              colorCode.length === 5
            ) {
              colorIndex = parseInt(colorCode.slice(2), 10);
            } else if (
              (colorCode.startsWith("@[F") && colorCode.endsWith("]")) ||
              (colorCode.startsWith("\\t[F") && colorCode.endsWith("]")) ||
              (colorCode.startsWith("^[F") && colorCode.endsWith("]"))
            ) {
              const inside = colorCode.includes("\\t")
                ? colorCode.slice(3, -1)
                : colorCode.slice(2, -1);
              const r = parseInt(inside.charAt(1), 10);
              const g = parseInt(inside.charAt(2), 10);
              const b = parseInt(inside.charAt(3), 10);
              colorIndex = 16 + 36 * r + 6 * g + b;
            } else if (colorCode === "@n") {
              colorIndex = 7;
            } else if (
              colorCode.match(/^\$[rRgGyYbBmMcCwWdD]$/) ||
              colorCode.match(/^@[rRgGyYbBmMcCwWdD]$/) ||
              colorCode.match(/^\{[rRgGyYbBmMcCwWdD]$/)
            ) {
              const c = colorCode.charAt(1);
              colorIndex = standardColorToIndex[c] || 7;
            } else if (colorCode.startsWith("&")) {
              const m = colorCode.match(/^&([rRgGyYbBmMcCwWdD])(\d{3})?$/);
              if (m) {
                if (m[2]) {
                  colorIndex = parseInt(m[2], 10);
                } else {
                  const c = m[1];
                  colorIndex = standardColorToIndex[c] || 7;
                }
              } else if (/^&\d{3}$/.test(colorCode)) {
                colorIndex = parseInt(colorCode.slice(1), 10);
              }
            } else if (colorCode.startsWith("{")) {
              if (colorCode.startsWith("{x") && colorCode.length === 5) {
                colorIndex = parseInt(colorCode.slice(2), 10);
              } else {
                const m = colorCode.match(/^\{([rRgGyYbBmMcCwWdD])(\d{3})?$/);
                if (m) {
                  if (m[2]) {
                    colorIndex = parseInt(m[2], 10);
                  } else {
                    const c = m[1];
                    colorIndex = standardColorToIndex[c] || 7;
                  }
                } else if (/^\{\d{3}$/.test(colorCode)) {
                  colorIndex = parseInt(colorCode.slice(1), 10);
                }
              }
            } else {
              colorIndex = 7;
            }
            converted += wrapColorCode(colorIndex);
          } else if (textContent) {
            converted += textContent;
          }
        });
        return converted;
      }

      function applyOriginalPattern(text, colors) {
        let result = "";
        let lastColorIndex = null;
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const colorIndex = colors[i % colors.length];
          if (!/\s/.test(char) && colorIndex !== lastColorIndex) {
            result += wrapColorCode(colorIndex);
            lastColorIndex = colorIndex;
          }
          result += char;
        }
        return result;
      }

      function distributeColorsEvenly(text, colors) {
        const n = text.length;
        const c = colors.length;
        if (n === 0) return "";
        const baseSize = Math.floor(n / c);
        let remainder = n % c;
        let segments = [];
        let startIndex = 0;
        for (let i = 0; i < c; i++) {
          const segmentSize = baseSize + (remainder > 0 ? 1 : 0);
          remainder = remainder > 0 ? remainder - 1 : remainder;
          const segment = text.slice(startIndex, startIndex + segmentSize);
          startIndex += segmentSize;
          segments.push({ segment, colorIndex: colors[i] });
        }
        let result = "";
        segments.forEach(({ segment, colorIndex }) => {
          if (!segment) return;
          let lastColorIndex = null;
          for (let i = 0; i < segment.length; i++) {
            const char = segment[i];
            if (!/\s/.test(char) && colorIndex !== lastColorIndex) {
              result += wrapColorCode(colorIndex);
              lastColorIndex = colorIndex;
            }
            result += char;
          }
        });
        return result;
      }

      function applySymmetricalPattern(text, colors) {
        const c = colors.length;
        if (c < 2) {
          return applyOriginalPattern(text, colors);
        }
        let result = "";
        let lastColorIndex = null;
        const cycleLength = 2 * c - 2;
        for (let i = 0; i < text.length; i++) {
          let mod = i % cycleLength;
          if (mod >= c) {
            mod = cycleLength - mod;
          }
          const colorIndex = colors[mod];
          const char = text[i];
          if (!/\s/.test(char) && colorIndex !== lastColorIndex) {
            result += wrapColorCode(colorIndex);
            lastColorIndex = colorIndex;
          }
          result += char;
        }
        return result;
      }

      function applyGradient() {
        const text = originalText;
        const pattern = document.getElementById("patternSelect").value;
        const select = document.getElementById("gradientSelect");
        const invert = document.getElementById("invertGradient").checked;
        const index = select.selectedIndex;
        if (index < 0) return;
        const gradient = gradients[index];
        const colors = invert ? gradient.colors.slice().reverse() : gradient.colors;
        let gradientText = "";
        if (pattern === "original") {
          gradientText = applyOriginalPattern(text, colors);
        } else if (pattern === "distributed") {
          gradientText = distributeColorsEvenly(text, colors);
        } else if (pattern === "symmetrical") {
          gradientText = applySymmetricalPattern(text, colors);
        }
        document.getElementById("textInput").value = gradientText;
        originalText = text;
        updateOutput();
      }

      function updateOutput() {
        const text = document.getElementById("textInput").value;
        document.getElementById("output").innerHTML = renderXterm(text);
      }

      function updateFont() {
        const selectedFont = document.getElementById("fontSelector").value;
        document.body.style.fontFamily = selectedFont;
      }

      function updateGradientPreview() {
        const select = document.getElementById("gradientSelect");
        const index = select.selectedIndex;
        if (index < 0) return;
        const gradient = gradients[index];
        const preview = document.getElementById("gradientPreview");
        if (gradient.colors.length > 1) {
          const invert = document.getElementById("invertGradient").checked;
          const colors = invert ? gradient.colors.slice().reverse() : gradient.colors;
          preview.style.background = `linear-gradient(to right, ${colors
            .map(xtermToRgbHex)
            .join(", ")})`;
        } else if (gradient.colors.length === 1) {
          preview.style.background = `${xtermToRgbHex(gradient.colors[0])}`;
        } else {
          preview.style.background = `black`;
        }
      }

      function createGradientOptionPreviews() {
        const select = document.getElementById("gradientSelect");
        Array.from(select.options).forEach((option, index) => {
          const gradient = gradients[index];
          const gradientCanvas = document.createElement("canvas");
          gradientCanvas.width = 100;
          gradientCanvas.height = 20;
          const ctx = gradientCanvas.getContext("2d");
          if (gradient.colors.length > 1) {
            const gradientStyle = ctx.createLinearGradient(0, 0, gradientCanvas.width, 0);
            gradient.colors.forEach((color, idx) => {
              const stopPosition = gradient.colors.length > 1 ? idx / (gradient.colors.length - 1) : 0;
              gradientStyle.addColorStop(stopPosition, xtermToRgbHex(color));
            });
            ctx.fillStyle = gradientStyle;
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          } else if (gradient.colors.length === 1) {
            ctx.fillStyle = xtermToRgbHex(gradient.colors[0]);
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          } else {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          }
          const dataURL = gradientCanvas.toDataURL();
          option.style.backgroundImage = `url(${dataURL})`;
          option.style.backgroundSize = "cover";
          option.style.backgroundRepeat = "no-repeat";
          option.style.paddingLeft = "30px";
        });
      }

      // --- Persistence using localStorage ---
      function loadCustomGradients() {
        const stored = localStorage.getItem("customGradients");
        if (stored) {
          try {
            return JSON.parse(stored);
          } catch (e) {
            return [];
          }
        }
        return [];
      }

      function saveCustomGradients() {
        localStorage.setItem("customGradients", JSON.stringify(customGradients));
      }

      // --- Built-in and Custom Gradients ---
      const builtInGradients = [
        { name: "Rainbow", colors: [196, 208, 226, 46, 51, 87] },
        { name: "Fire", colors: [208, 166, 124, 94, 95, 167] },
        { name: "Ocean", colors: [59, 95, 131, 167, 209, 215] },
        { name: "Mystic", colors: [124, 132, 138, 145, 150, 155] },
        { name: "Shadow Eclipse", colors: [59, 95, 131, 167] },
        { name: "Frosty Dawn", colors: [209, 215, 221] },
        { name: "Eternal Ember", colors: [208, 166, 124, 94, 95] },
        { name: "Ethereal Vex", colors: [208, 124, 94, 100, 136] },
        { name: "Night Whisper", colors: [59, 95, 131, 167] },
        { name: "Crystal Duality", colors: [95, 59] },
        { name: "Obsidian Mirage", colors: [61, 62, 97, 96] },
        { name: "Moonlight Trio", colors: [132, 131, 167] },
        { name: "Dusk Crown", colors: [127, 133, 139] },
        { name: "Dream Tides", colors: [145, 151, 150, 151] },
        { name: "Mystic Charm", colors: [145, 139, 133, 127] },
        { name: "Fallen Mark", colors: [221, 220, 178, 172] },
        { name: "Destiny Shard", colors: [130, 94, 196] },
        { name: "Shattered Echo", colors: [124, 88, 52] },
        { name: "Stormsong", colors: [172, 178, 220] },
        { name: "Gale Helix", colors: [221, 227, 220] },
        { name: "Inferno Crest", colors: [174, 102, 109] },
        { name: "Endless Night", colors: [59, 95, 131, 167] },
        { name: "Abyss Sigil", colors: [131, 95, 59] },
        { name: "Sunlit Peaks", colors: [157, 121, 85, 49, 50] },
        { name: "Shattered Star", colors: [51, 87] },
        { name: "Endless Dreams", colors: [96, 97, 103, 97] },
        { name: "Starlight Despair", colors: [96, 60, 61, 97, 96] },
        {
          name: "Dream Eclipse",
          colors: [95, 101, 107, 113, 119, 113, 107, 101],
        },
        { name: "Everlasting Light", colors: [69, 68, 67, 61] },
        { name: "Ancient Havens", colors: [60, 67, 61, 60] },
        { name: "Eternal Radiance", colors: [226, 227, 228, 229] },
        { name: "Glory Flares", colors: [230, 194, 193, 226] },
        { name: "Gilded Infinity", colors: [201, 207, 213, 219] },
        { name: "Arcane Symbol", colors: [225, 231, 225, 219] },
        { name: "Shattered Stars", colors: [230, 229, 228, 227] },
        { name: "Eclipsed Glory", colors: [226, 190, 154] },
        { name: "Mystic Rays", colors: [230, 228, 222, 216] },
        { name: "Flickering Fire", colors: [230, 228, 222, 216] },
        { name: "Burning Ash", colors: [214, 178, 130, 94, 95] },
        { name: "Silent Embrace", colors: [214, 178] },
        { name: "Eternal Breeze", colors: [124, 130, 136] },
        { name: "Flowing Mist", colors: [142, 148, 154, 190, 226] },
        { name: "Sacred Dreams", colors: [96, 103, 110, 111] },
        { name: "Ember Relic", colors: [116, 121, 157, 151] },
        { name: "Enigmatic Shadows", colors: [72, 85, 84, 78] },
        { name: "Ancient Whisper", colors: [72, 66, 85, 84] },
        { name: "Eclipsed Crown", colors: [220, 214, 208, 209, 210] },
        { name: "Eternal Shards", colors: [174, 138, 102] },
        { name: "Mystery Echo", colors: [59, 95, 131, 124, 88, 52] },
        { name: "Olympian Dreams", colors: [111, 110, 153, 195, 153] },
        { name: "Crown Armor", colors: [110, 111] },
        { name: "Whispering Winds", colors: [145, 188, 181, 174, 131] },
        { name: "Titan Mark", colors: [167, 226] },
        { name: "Shattered Worlds", colors: [187, 186, 144, 138, 132] },
        { name: "Ethereal Machine", colors: [131, 167] },
        { name: "Mystic Wisdom", colors: [137, 138, 139, 175, 211] },
        { name: "Single Hue", colors: [139] },
        { name: "Radiant Arcane", colors: [27, 63, 99, 135, 171] },
        { name: "Warden's Hue", colors: [207] },
        { name: "Endless Nightfall", colors: [51, 87, 123, 159] },
        { name: "Eclipse Shard", colors: [195, 231] },
        { name: "Elemental Fury", colors: [81, 111, 141, 171, 141] },
        { name: "Steel Eclipse", colors: [33, 39, 45, 39, 33] },
        { name: "Ghoul Glow", colors: [154, 155, 191, 190, 191, 155, 154] },
        {
          name: "Celestial Scales",
          colors: [81, 87, 159, 194, 192, 227, 220, 226, 227, 192, 159, 87, 81],
        },
        {
          name: "Solar Flare",
          colors: [196, 208, 220, 226, 220, 208, 196, 33],
        },
        {
          name: "Cerebral Rift",
          colors: [175, 174, 168, 169, 175, 174, 168, 169],
        },
        { name: "Abyssal Armor", colors: [69, 68, 67, 61, 60, 61, 67, 68, 69] },
        {
          name: "Sunset Wail",
          colors: [231, 225, 218, 211, 204, 197, 204, 211, 218, 225, 231],
        },
        { name: "Verdict Veil", colors: [142, 143, 144, 150, 151] },
        { name: "Stratosphere Surge", colors: [41, 87, 159, 194, 192] },
        { name: "Venomous Gaze", colors: [103, 102, 138, 174, 78] },
        { name: "Moonlit Veil", colors: [220, 221, 227, 228] },
        {
          name: "Gradient_Ex_Sequence_1",
          colors: [167, 131, 132, 95, 96, 97, 61, 62, 61, 97, 96, 95, 132, 131, 167],
        },
        {
          name: "Gradient_Ex_Sequence_2",
          colors: [127, 133, 139, 145, 151, 150, 151, 145, 139, 133, 127],
        },
        {
          name: "Gradient_Ex_Sequence_3",
          colors: [221, 220, 178, 172, 130, 94, 196, 160, 124, 88, 52],
        },
        {
          name: "Gradient_Ex_Sequence_4",
          colors: [172, 178, 220, 221, 227, 221, 220, 178, 172],
        },
        {
          name: "Gradient_Ex_Sequence_5",
          colors: [59, 95, 131, 167, 131, 95, 59],
        },
        {
          name: "Gradient_Ex_Sequence_6",
          colors: [157, 121, 85, 49, 50, 51, 87, 123, 87, 51, 50, 49],
        },
        {
          name: "Gradient_Ex_Sequence_7",
          colors: [96, 97, 103, 97, 96, 60, 61, 97, 96],
        },
        {
          name: "Gradient_Ex_Sequence_8",
          colors: [95, 101, 107, 113, 119, 113, 107, 101, 95, 101],
        },
        {
          name: "Gradient_Ex_Sequence_9",
          colors: [69, 68, 67, 61, 60, 69, 68, 67, 61, 60],
        },
        {
          name: "Gradient_Ex_Sequence_10",
          colors: [226, 227, 228, 229, 230, 194, 193],
        },
        {
          name: "Gradient_Ex_Sequence_11",
          colors: [201, 207, 213, 219, 225, 231, 225, 219, 213, 207, 201, 200],
        },
        {
          name: "Gradient_Ex_Sequence_12",
          colors: [230, 229, 228, 227, 226, 190, 154, 190, 226, 227, 228, 229],
        },
        {
          name: "Gradient_Ex_Sequence_13",
          colors: [230, 228, 222, 216, 230, 228, 222, 216, 215],
        },
        {
          name: "Gradient_Ex_Sequence_14",
          colors: [214, 178, 130, 94, 95, 59, 214, 178, 130, 94, 95, 59],
        },
        {
          name: "Gradient_Ex_Sequence_15",
          colors: [124, 130, 136, 142, 148, 154, 190, 226, 228],
        },
        {
          name: "Gradient_Ex_Sequence_16",
          colors: [96, 103, 110, 111, 116, 121, 157, 151, 145, 139],
        },
        {
          name: "Gradient_Ex_Sequence_17",
          colors: [72, 85, 84, 78, 72, 66, 85, 84, 72],
        },
        {
          name: "Gradient_Ex_Sequence_18",
          colors: [220, 214, 208, 209, 210, 174, 138, 102, 109, 66, 67],
        },
        {
          name: "Gradient_Ex_Sequence_19",
          colors: [59, 95, 131, 124, 88, 52],
        },
        {
          name: "Gradient_Ex_Sequence_20",
          colors: [111, 110, 153, 195, 153, 110, 111],
        },
        {
          name: "Gradient_Ex_Sequence_21",
          colors: [145, 188, 181, 174, 131, 167, 145, 188, 181, 174, 131, 167],
        },
        {
          name: "Gradient_Ex_Sequence_22",
          colors: [187, 186, 144, 138, 132, 131, 167, 131, 132, 138, 144, 186, 187],
        },
        {
          name: "Gradient_Ex_Sequence_23",
          colors: [137, 138, 139, 175, 211, 139, 138, 173, 210, 211],
        },
        {
          name: "Gradient_Ex_Sequence_24",
          colors: [27, 63, 99, 135, 171, 207, 171, 135, 99],
        },
        {
          name: "Gradient_Ex_Sequence_25",
          colors: [51, 87, 123, 159, 195, 231, 195, 159, 123],
        },
        {
          name: "Gradient_Ex_Sequence_26",
          colors: [81, 111, 141, 171],
        },
        {
          name: "Gradient Sequence 27",
          colors: [96, 96, 96, 96, 60, 60, 60, 60, 61, 61, 61, 61, 97, 97, 97, 97],
        },
        {
          name: "Gradient Sequence 28",
          colors: [71, 83, 119, 155, 191, 227, 191, 155, 119],
        },
        {
          name: "Gradient Sequence 29",
          colors: [81, 87, 123, 159, 195, 231, 195, 159, 123],
        },
        {
          name: "Gradient Sequence 30",
          colors: [120, 121, 122, 123, 124, 125, 126, 127, 128, 129],
        },
        {
          name: "Gradient Sequence 31",
          colors: [161, 198, 126, 90, 91, 97, 108, 109, 110, 111, 71, 72, 73, 74, 75],
        },
        {
          name: "Gradient Sequence 32",
          colors: [33, 32, 31, 30, 29, 28, 29, 30, 31],
        },
        { name: "Gradient Sequence 33", colors: [96, 103, 109, 110, 153, 195] },
        {
          name: "Gradient Sequence 34",
          colors: [148, 142, 136, 137, 216, 102, 66],
        },
        {
          name: "Gradient Sequence 35",
          colors: [22, 23, 30, 36, 43, 50, 43, 36, 30],
        },
        {
          name: "Gradient Sequence 36",
          colors: [94, 53, 23, 29, 35, 41, 47, 41, 35, 29, 23, 53, 94],
        },
        {
          name: "Gradient Sequence 37",
          colors: [131, 94, 100, 144, 187, 186, 144, 138, 132],
        },
        {
          name: "Gradient Sequence 38",
          colors: [89, 90, 91, 92, 93, 94, 95, 96, 97],
        },
        { name: "Lush Meadow", colors: [46, 82, 118, 154, 190] },
        { name: "Midnight Shadows", colors: [16, 22, 28, 34, 40, 46] },
        { name: "Sunset Blaze", colors: [202, 166, 130, 94, 58] },
        {
          name: "Wailing Abomination",
          colors: [166, 172, 130, 136, 94, 100, 58, 64, 106, 112, 142, 148],
        },
        {
          name: "Putrid Funk",
          colors: [130, 136, 142, 148, 154, 148, 142, 136, 135, 134, 133, 132],
        }
      ];

      // Load custom gradients from localStorage and merge them.
      let customGradients = loadCustomGradients();
      let gradients = builtInGradients.concat(customGradients);
      let originalText = "";

      function populateGradientSelect() {
        const select = document.getElementById("gradientSelect");
        select.innerHTML = "";
        gradients.forEach((g, idx) => {
          const option = document.createElement("option");
          option.value = g.name;
          option.textContent = g.name;
          option.dataset.gradientIndex = idx;
          select.appendChild(option);
        });
        createGradientOptionPreviews();
      }

      function onGradientChange() {
        updateGradientPreview();
        applyGradient();
      }

      function onPatternChange() {
        applyGradient();
      }

      function onTextInput() {
        const mode = getSelectedMode();
        const text = document.getElementById("textInput").value;
        if (mode === "edit") {
          let plain = text.replace(
            /\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rKrRgGyYbBmMcCwWdD]|@[rKrRgGyYbBmMcCwWdD]|\{[rKrRgGyYbBmMcCwWdD]|\&[rKrRgGyYbBmMcCwWdD](?:\d{3})?|\&\d{3}/g,
            ""
          );
          originalText = plain;
          applyGradient();
        } else {
          updateOutput();
        }
      }

      function getSelectedMode() {
        const modes = document.getElementsByName("mode");
        for (const mode of modes) {
          if (mode.checked) return mode.value;
        }
        return "edit";
      }

      const modeSelectors = document.getElementsByName("mode");
      modeSelectors.forEach((modeSelector) => {
        modeSelector.addEventListener("change", () => {
          if (getSelectedMode() === "view") {
            document.getElementById("gradientControls").classList.add("disabled");
          } else {
            document.getElementById("gradientControls").classList.remove("disabled");
          }
          updateOutput();
        });
      });

      // Toggle Custom Gradient Section
      document.getElementById("toggleCustomGradientButton").addEventListener("click", function () {
        const addGradientDiv = document.getElementById("addGradient");
        if (addGradientDiv.style.display === "none" || addGradientDiv.style.display === "") {
          addGradientDiv.style.display = "block";
          this.value = "Hide custom gradient";
        } else {
          addGradientDiv.style.display = "none";
          this.value = "Create custom gradient";
        }
      });

      // Toggle Manage Custom Gradients Section
      document.getElementById("toggleManageCustomGradients").addEventListener("click", function () {
        const manageDiv = document.getElementById("manageCustomGradients");
        if (manageDiv.style.display === "none" || manageDiv.style.display === "") {
          manageDiv.style.display = "block";
          this.value = "Hide custom gradients";
          populateCustomGradientsList();
        } else {
          manageDiv.style.display = "none";
          this.value = "Manage custom gradients";
        }
      });

      // Update the preview in the create custom gradient form
      function updateCustomGradientPreview() {
        const codesStr = document.getElementById("newGradientCodes").value.trim();
        if (!codesStr) {
          document.getElementById("customGradientPreview").style.background = "";
          return;
        }
        const codes = codesStr.split(/\s+/).map(item => parseInt(item, 10));
        if (codes.some(code => isNaN(code) || code < 0 || code > 255)) {
          document.getElementById("customGradientPreview").style.background = "";
          return;
        }
        const colors = codes.map(xtermToRgbHex);
        let backgroundStyle = "";
        if (colors.length > 1) {
          backgroundStyle = `linear-gradient(to right, ${colors.join(", ")})`;
        } else if (colors.length === 1) {
          backgroundStyle = colors[0];
        }
        document.getElementById("customGradientPreview").style.background = backgroundStyle;
      }
      document.getElementById("newGradientCodes").addEventListener("input", updateCustomGradientPreview);

      // Remove "invalid" class on input when valid
      document.getElementById("newGradientName").addEventListener("input", function () {
        if (this.validity.valid) this.classList.remove("invalid");
      });
      document.getElementById("newGradientCodes").addEventListener("input", function () {
        if (this.validity.valid) this.classList.remove("invalid");
      });

      // This function adds the gradient and verifies valid color codes.
      function verifyAndAddGradient() {
        const gName = document.getElementById("newGradientName").value;
        const gColors = [];
        const colorCodes = document.getElementById("newGradientCodes").value.split(" ");
        const wasConverted = colorCodes.every((item) => {
          const conversion = parseInt(item);
          if (!isNaN(conversion) && conversion >= 0 && conversion <= 255) {
            gColors.push(conversion);
            return true;
          } else {
            return false;
          }
        });
        if (wasConverted) {
          customGradients.push({
            name: gName,
            colors: gColors
          });
          saveCustomGradients();
          gradients = builtInGradients.concat(customGradients);
          populateGradientSelect();
          document.getElementById("newGradientName").value = "";
          document.getElementById("newGradientCodes").value = "";
          document.getElementById("customGradientPreview").style.background = "";
        } else {
          alert("Color codes must be a space separated list of numbers between 0 and 255.");
        }
      }

      // Ignore the click if the input isn't valid and trigger shake animation.
      function addGradientClick() {
        const nameInput = document.getElementById("newGradientName");
        const codesInput = document.getElementById("newGradientCodes");
        if (nameInput.validity.valid && codesInput.validity.valid) {
          verifyAndAddGradient();
        } else {
          if (!nameInput.validity.valid) {
            nameInput.classList.add("invalid", "shake");
            nameInput.addEventListener("animationend", () => {
              nameInput.classList.remove("shake");
            }, { once: true });
          }
          if (!codesInput.validity.valid) {
            codesInput.classList.add("invalid", "shake");
            codesInput.addEventListener("animationend", () => {
              codesInput.classList.remove("shake");
            }, { once: true });
          }
        }
      }
      document.getElementById("newGradientProcess").addEventListener("click", addGradientClick);

      // --- Editing Custom Gradients in the Management Section ---

      // Update the preview for an editable custom gradient
      function updateEditGradientPreview(codesString, previewBox) {
        const codesArr = codesString.trim().split(/\s+/).map(item => parseInt(item, 10));
        if (codesArr.some(code => isNaN(code) || code < 0 || code > 255)) {
          previewBox.style.background = "";
          return;
        }
        const colors = codesArr.map(xtermToRgbHex);
        let backgroundStyle = "";
        if (colors.length > 1) {
          backgroundStyle = `linear-gradient(to right, ${colors.join(", ")})`;
        } else if (colors.length === 1) {
          backgroundStyle = colors[0];
        }
        previewBox.style.background = backgroundStyle;
      }

      // Populate the list of custom gradients for management (with inline editing)
      function populateCustomGradientsList() {
        const container = document.getElementById("customGradientsList");
        container.innerHTML = "";
        if (customGradients.length === 0) {
          container.innerHTML = "<p>No custom gradients added.</p>";
          return;
        }
        customGradients.forEach((grad, index) => {
          const gradDiv = document.createElement("div");
          gradDiv.classList.add("custom-gradient-item");

          // Preview box
          const previewBox = document.createElement("div");
          previewBox.classList.add("custom-gradient-preview");
          // Initially update preview using stored codes
          updateEditGradientPreview(grad.colors.join(" "), previewBox);

          // Name input
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.classList.add("edit-gradient-name");
          nameInput.value = grad.name;

          // Codes input
          const codesInput = document.createElement("input");
          codesInput.type = "text";
          codesInput.classList.add("edit-gradient-codes");
          codesInput.value = grad.colors.join(" ");
          codesInput.addEventListener("input", function() {
            updateEditGradientPreview(this.value, previewBox);
          });

          // Save button
          const saveBtn = document.createElement("button");
          saveBtn.textContent = "Save";
          saveBtn.addEventListener("click", function() {
            saveEditedGradient(index, nameInput, codesInput);
          });

          // Remove button
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", function() {
            removeCustomGradient(index);
          });

          gradDiv.appendChild(previewBox);
          gradDiv.appendChild(nameInput);
          gradDiv.appendChild(codesInput);
          gradDiv.appendChild(saveBtn);
          gradDiv.appendChild(removeBtn);

          container.appendChild(gradDiv);
        });
      }

      // Save the edited custom gradient
      function saveEditedGradient(index, nameInput, codesInput) {
        const newName = nameInput.value.trim();
        const codesStr = codesInput.value.trim();
        if (!newName.match(/^[\w\s]+$/)) {
          nameInput.classList.add("invalid", "shake");
          nameInput.addEventListener("animationend", () => {
            nameInput.classList.remove("shake");
          }, { once: true });
          return;
        }
        if (!codesStr.match(/^(?:[0-9]{1,3}(?:\s+[0-9]{1,3})*)$/)) {
          codesInput.classList.add("invalid", "shake");
          codesInput.addEventListener("animationend", () => {
            codesInput.classList.remove("shake");
          }, { once: true });
          return;
        }
        const codesArr = codesStr.split(/\s+/).map(item => parseInt(item, 10));
        if (codesArr.some(code => isNaN(code) || code < 0 || code > 255)) {
          codesInput.classList.add("invalid", "shake");
          codesInput.addEventListener("animationend", () => {
            codesInput.classList.remove("shake");
          }, { once: true });
          return;
        }
        customGradients[index].name = newName;
        customGradients[index].colors = codesArr;
        saveCustomGradients();
        gradients = builtInGradients.concat(customGradients);
        populateGradientSelect();
        populateCustomGradientsList();
      }

      // Remove a custom gradient
      function removeCustomGradient(index) {
        customGradients.splice(index, 1);
        saveCustomGradients();
        gradients = builtInGradients.concat(customGradients);
        populateGradientSelect();
        populateCustomGradientsList();
      }

      // Format conversion event
      document.getElementById("formatSelector").addEventListener("change", function () {
        const text = document.getElementById("textInput").value;
        const newFormat = this.value;
        const converted = convertColorCodesToFormat(text, newFormat);
        document.getElementById("textInput").value = converted;
        if (getSelectedMode() === "edit") {
          originalText = converted.replace(
            /\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rKrRgGyYbBmMcCwWdD]|@[rKrRgGyYbBmMcCwWdD]|\{[rKrRgGyYbBmMcCwWdD]|\&[rKrRgGyYbBmMcCwWdD](?:\d{3})?|\&\d{3}/g,
            ""
          );
          applyGradient();
        } else {
          updateOutput();
        }
      });

      function initialize() {
        populateGradientSelect();
        updateGradientPreview();
        updateOutput();
        // If the create-gradient form already has color codes, update its preview.
        updateCustomGradientPreview();
      }

      document.getElementById("fontSelector").addEventListener("change", updateFont);
      document.getElementById("textInput").addEventListener("input", onTextInput);
      document.getElementById("gradientSelect").addEventListener("change", onGradientChange);
      document.getElementById("patternSelect").addEventListener("change", onPatternChange);
      document.getElementById("invertGradient").addEventListener("change", onGradientChange);

      initialize();
    </script>
  </body>
</html>
